public class Transmit implements Encrypt {
	private int[] key = { 0x00000000, 0x00000000, 0x00000000, 0x00000000 };
	private int[] plainText = { 0x55555555, 0x55555555, 0x55555555, 0x55555555 };
	private int[] cipherText = { 0x55555555, 0x55555555, 0x55555555, 0x55555555 };
	private static final int[][] MDS = new int[4][256];
	private static final int GF256_FDBK = 0x169;
	private static final int GF256_FDBK_2 = 0x169 / 2;
	private static final int GF256_FDBK_4 = 0x169 / 4;

	public Transmit() {

	}

	@Override
	public int[] Encrypt() {
		// TODO Auto-generated method stub
		return cipherText;
	}

	public int[][] allSboxToMDS(int val) {
		int A, B, C, D;

		A = (val >> 24) & 0xFF;
		B = (val >> 16) & 0xFF;
		C = (val >> 8) & 0xFF;
		D = (val) & 0xFF;

		A = q0(A);
		B = q1(B);
		C = q0(C);
		D = q1(D);

		int endResult = (A << 24) | (B << 16) | (C << 8) | D;
		int S0 = 0x17A019B9;
		int S1 = 0x03A45B78;
		int testResult = endResult ^ S0;

		int A2, B2, C2, D2;

		A2 = q0(testResult);
		B2 = q1(testResult);
		C2 = q0(testResult);
		D2 = q1(testResult);

		int endResult2 = (A2 << 24) | (B2 << 16) | (C2 << 8) | D2;
		int testResult2 = endResult ^ S1;

		int A3, B3, C3, D3;

		A3 = q0(testResult2);
		B3 = q1(testResult2);
		C3 = q0(testResult2);
		D3 = q1(testResult2);

		return null;
	}

	public static int[][] MDS(int A, int B, int C, int D) {

		int[] m1 = new int[2];
		int[] mX = new int[2];
		int[] mY = new int[2];
		int i, j;
		for (i = 0; i < 256; i++) {
			j = P[0][i] & 0xFF; // compute all the matrix elements
			m1[0] = j;
			mX[0] = Mx_X(j) & 0xFF;
			mY[0] = Mx_Y(j) & 0xFF;
			j = P[1][i] & 0xFF;
			m1[1] = j;
			mX[1] = Mx_X(j) & 0xFF;
			mY[1] = Mx_Y(j) & 0xFF;
			MDS[0][i] = m1[A] << 0 | // fill matrix w/ above elements
					mX[A] << 8 | mY[A] << 16 | mY[A] << 24;
			MDS[1][i] = mY[B] << 0 | mY[B] << 8 | mX[B] << 16 | m1[B] << 24;
			MDS[2][i] = mX[C] << 0 | mY[C] << 8 | m1[C] << 16 | mY[C] << 24;
			MDS[3][i] = mX[D] << 0 | m1[D] << 8 | mY[D] << 16 | mX[D] << 24;
		}

		return null;
	}

	public static int q0(int val) {
		int A = (val & 0xF0) >> 4;
		int B = val & 0x0F;

		int[] t0 = { 0x8, 0x1, 0x7, 0xA, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5,
				0x9, 0xE, 0xC, 0xA, 0x4 };
		int[] t1 = { 0xE, 0xC, 0xB, 0x8, 0x1, 0x2, 0x3, 0x5, 0xF, 0x4, 0xA,
				0x6, 0x7, 0x0, 0x9, 0xD };
		int[] t2 = { 0xB, 0xA, 0x5, 0xE, 0x6, 0xD, 0x9, 0x0, 0xC, 0x8, 0xF,
				0x3, 0x2, 0x4, 0x7, 0x1 };
		int[] t3 = { 0xD, 0x7, 0xF, 0x4, 0x1, 0x2, 0x6, 0xE, 0x9, 0xB, 0x3,
				0x0, 0x8, 0x5, 0xC, 0xA };

		int A2 = A ^ B;
		A2 = t0[A2];
		int B2 = qFunction(A, B);
		B2 = t1[B2];
		int A3 = A2 ^ B2;
		A3 = t2[A3];
		int B3 = qFunction(A2, B2);
		B3 = t3[B3];
		int endResult = (A3 << 4) | B3;

		return endResult;

	}

	public static int q1(int val) {
		int A = (val & 0xF0) >> 4;
		int B = val & 0x0F;

		int[] t0 = { 0x2, 0x8, 0xB, 0xD, 0xF, 0x7, 0x6, 0xE, 0x3, 0x1, 0x9,
				0x4, 0x0, 0xA, 0xC, 0x5 };
		int[] t1 = { 0x1, 0xE, 0x2, 0xB, 0x4, 0xC, 0x3, 0x7, 0x6, 0xD, 0xA,
				0x5, 0xF, 0x9, 0x0, 0x8 };
		int[] t2 = { 0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA, 0x0, 0xE, 0xD,
				0x8, 0x2, 0xB, 0x3, 0xF };
		int[] t3 = { 0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE, 0x6, 0x4, 0x7,
				0xF, 0x2, 0x0, 0x8, 0xA };

		int A2 = A ^ B;
		A2 = t0[A2];
		int B2 = qFunction(A, B);
		B2 = t1[B2];
		int A3 = A2 ^ B2;
		A3 = t2[A3];
		int B3 = qFunction(A2, B2);
		B3 = t3[B3];
		int endResult = (A3 & 0xE0) | (B3 & 0x1F);

		return endResult;

	}

	public static int qFunction(int A, int B) {
		int Btest = B >> 1;
		int Btest2 = Btest ^ A;
		int Aa = A;
		if (Aa % 2 == 0)
			Aa = 8;
		else
			Aa = 0;
		int B2 = Aa ^ Btest2;
		return B2;

	}
}
